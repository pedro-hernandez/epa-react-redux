"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant = require("invariant");
var Subscription_1 = require("react-redux/lib/utils/Subscription");
var PropTypes_1 = require("react-redux/lib/utils/PropTypes");
var connect_1 = require("react-redux/lib/connect/connect");
var Link_1 = require("./Link");
var hotReloadingVersion = 0;
var dummyState = {};
function noop() { }
function makeSelectorStateful(sourceSelector, store) {
    var selector = {
        run: function runComponentSelector(props) {
            try {
                var nextProps = sourceSelector(store.getState(), props);
                if (nextProps !== selector.props || selector.error) {
                    selector.shouldComponentUpdate = true;
                    selector.props = nextProps;
                    selector.error = null;
                }
            }
            catch (error) {
                selector.shouldComponentUpdate = true;
                selector.error = error;
            }
        }
    };
    return selector;
}
function connectAdvanced(selectorFactory, _a) {
    var _b = _a.getDisplayName, getDisplayName = _b === void 0 ? function (name) { return "ConnectAdvanced(" + name + ")"; } : _b, _c = _a.methodName, methodName = _c === void 0 ? 'connectAdvanced' : _c, _d = _a.renderCountProp, renderCountProp = _d === void 0 ? undefined : _d, _e = _a.shouldHandleStateChanges, shouldHandleStateChanges = _e === void 0 ? true : _e, _f = _a.storeKey, storeKey = _f === void 0 ? 'store' : _f, _g = _a.withRef, withRef = _g === void 0 ? false : _g, connectOptions = __rest(_a, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef"]);
    if (_a === void 0) { _a = {}; }
    var subscriptionKey = storeKey + 'Subscription';
    var version = hotReloadingVersion++;
    var contextTypes = (_h = {},
        _h[storeKey] = PropTypes_1.storeShape,
        _h[subscriptionKey] = PropTypes_1.subscriptionShape,
        _h);
    var childContextTypes = (_j = {},
        _j[subscriptionKey] = PropTypes_1.subscriptionShape,
        _j);
    var wrappedComponentName = 'Component';
    var displayName = getDisplayName(wrappedComponentName);
    var selectorFactoryOptions = __assign({}, connectOptions, { getDisplayName: getDisplayName,
        methodName: methodName,
        renderCountProp: renderCountProp,
        shouldHandleStateChanges: shouldHandleStateChanges,
        storeKey: storeKey,
        withRef: withRef,
        displayName: displayName,
        wrappedComponentName: wrappedComponentName });
    var Connect = (function (_super) {
        __extends(Connect, _super);
        function Connect(props, context) {
            var _this = _super.call(this, props, context) || this;
            _this.version = version;
            _this.state = {};
            _this.renderCount = 0;
            _this.store = props[storeKey] || context[storeKey];
            _this.propsMode = Boolean(props[storeKey]);
            _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);
            invariant(_this.store, "Could not find \"" + storeKey + "\" in either the context or props of " +
                ("\"" + displayName + "\". Either wrap the root component in a <Provider>, ") +
                ("or explicitly pass \"" + storeKey + "\" as a prop to \"" + displayName + "\"."));
            _this.initSelector();
            _this.initSubscription();
            return _this;
        }
        Connect.prototype.getChildContext = function () {
            var subscription = this.propsMode ? null : this.subscription;
            return _a = {}, _a[subscriptionKey] = subscription || this.context[subscriptionKey], _a;
            var _a;
        };
        Connect.prototype.componentDidMount = function () {
            if (!shouldHandleStateChanges)
                return;
            this.subscription.trySubscribe();
            this.selector.run(this.props);
            if (this.selector.shouldComponentUpdate)
                this.forceUpdate();
        };
        Connect.prototype.componentWillReceiveProps = function (nextProps) {
            this.selector.run(nextProps);
        };
        Connect.prototype.shouldComponentUpdate = function () {
            return this.selector.shouldComponentUpdate;
        };
        Connect.prototype.componentWillUnmount = function () {
            if (this.subscription)
                this.subscription.tryUnsubscribe();
            this.subscription = null;
            this.notifyNestedSubs = noop;
            this.store = null;
            this.selector.run = noop;
            this.selector.shouldComponentUpdate = false;
        };
        Connect.prototype.getWrappedInstance = function () {
            invariant(withRef, "To access the wrapped instance, you need to specify " +
                ("{ withRef: true } in the options argument of the " + methodName + "() call."));
            return this.wrappedInstance;
        };
        Connect.prototype.setWrappedInstance = function (ref) {
            this.wrappedInstance = ref;
        };
        Connect.prototype.initSelector = function () {
            var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
            this.selector = makeSelectorStateful(sourceSelector, this.store);
            this.selector.run(this.props);
        };
        Connect.prototype.initSubscription = function () {
            if (!shouldHandleStateChanges)
                return;
            var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
            this.subscription = new Subscription_1.default(this.store, parentSub, this.onStateChange.bind(this));
            this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
        };
        Connect.prototype.onStateChange = function () {
            this.selector.run(this.props);
            if (!this.selector.shouldComponentUpdate) {
                this.notifyNestedSubs();
            }
            else {
                this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
                this.setState(dummyState);
            }
        };
        Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function () {
            this.componentDidUpdate = undefined;
            this.notifyNestedSubs();
        };
        Connect.prototype.isSubscribed = function () {
            return Boolean(this.subscription) && this.subscription.isSubscribed();
        };
        Connect.prototype.addExtraProps = function (props) {
            if (!withRef && !renderCountProp && !(this.propsMode && this.subscription))
                return props;
            var withExtras = __assign({}, props);
            if (withRef)
                withExtras.ref = this.setWrappedInstance;
            if (renderCountProp)
                withExtras[renderCountProp] = this.renderCount++;
            if (this.propsMode && this.subscription)
                withExtras[subscriptionKey] = this.subscription;
            return withExtras;
        };
        Connect.prototype.preRender = function () {
            var selector = this.selector;
            selector.shouldComponentUpdate = false;
            if (selector.error) {
                throw selector.error;
            }
            else {
                return this.addExtraProps(selector.props);
            }
        };
        return Connect;
    }(Link_1.Link));
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;
    if (process.env.NODE_ENV !== 'production') {
        Connect.prototype.componentWillUpdate = function componentWillUpdate() {
            if (this.version !== version) {
                this.version = version;
                this.initSelector();
                if (this.subscription)
                    this.subscription.tryUnsubscribe();
                this.initSubscription();
                if (shouldHandleStateChanges)
                    this.subscription.trySubscribe();
            }
        };
    }
    return Connect;
    var _h, _j;
}
exports.connectAdvanced = connectAdvanced;
exports.rawReduxLink = connect_1.createConnect({ connectHOC: connectAdvanced });
exports.reduxLink = function (config) {
    return exports.rawReduxLink(config.mapStateToProps, config.mapDispatchToProps);
};
//# sourceMappingURL=reduxLink.js.map